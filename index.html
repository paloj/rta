<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="favicon.ico" />
  <title>Lightweight RTA</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0b0b; color:#ddd; font-family:system-ui, sans-serif; }
    body { display:flex; flex-direction:column; }
    #top { padding:10px; display:flex; gap:10px; align-items:center; flex-wrap:wrap; user-select:none; }
    #top.hidden { display:none; }
    .menu-toggle { margin:10px; }
    #menuHeader { position:fixed; top:8px; left:8px; z-index:30; padding:0; display:flex; align-items:center; gap:10px; }
    #menuBtn { margin:0; opacity:0.9; }
    body.menu-collapsed #menuBtn { opacity:0.35; }
    #menuPanel { padding:10px; display:flex; gap:10px; flex-wrap:wrap; position:fixed; z-index:20; background:#0f0f0f; border:1px solid #222; border-radius:12px; box-shadow:0 8px 20px rgba(0,0,0,0.45); transform:translateX(-8px); opacity:0; pointer-events:none; transition:transform 160ms ease, opacity 160ms ease; }
    #menuPanel.hidden { display:none; }
    #menuPanel.open { transform:translateX(0); opacity:1; pointer-events:auto; }
    .menu-tab.active { border-color:#6aa; box-shadow:0 0 0 1px rgba(102,170,170,0.4); }
    .menu-rows { display:flex; flex-direction:column; gap:10px; }
    .menu-row { padding:10px; display:flex; gap:10px; align-items:center; flex-wrap:wrap; position:fixed; z-index:10; background:#0d0d0d; border:1px solid #222; border-radius:12px; box-shadow:0 8px 18px rgba(0,0,0,0.45); transform:translateX(-8px); opacity:0; pointer-events:none; transition:transform 160ms ease, opacity 160ms ease; max-height:calc(100vh - 24px); overflow-y:auto; overscroll-behavior:contain; -webkit-overflow-scrolling:touch; }
    .menu-row.hidden { display:none; }
    .menu-row.open { transform:translateX(0); opacity:1; pointer-events:auto; }
    .tooltip { position:absolute; padding:4px 8px; background:#101010; color:#f0f0f0; border:1px solid #333; border-radius:4px; font-size:12px; pointer-events:none; white-space:nowrap; transform:translate(-50%, -100%); box-shadow:0 0 10px rgba(0,0,0,0.6); }
    .tooltip.hidden { display:none; }
    button, select, input { background:#1a1a1a; color:#ddd; border:1px solid #333; padding:6px 10px; border-radius:8px; }
    label { display:flex; gap:6px; align-items:center; background:#141414; border:1px solid #333; padding:6px 10px; border-radius:999px; }
    input[type="checkbox"] { width:16px; height:16px; }
    input[type="number"] { width:92px; }
    .peak-section { display:flex; gap:10px; align-items:center; }
    canvas { display:block; width:100%; flex:1 1 0; min-height:0; height:100%; }
    .auto-oct-controls { display:flex; gap:10px; align-items:center; }
    .auto-oct-controls.hidden { display:none; }
    .style-block { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .style-submenu { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    .style-block label span,
    .style-submenu label span { font-size:12px; }
    .style-group { display:flex; flex-wrap:wrap; gap:10px; align-items:center; padding:8px 10px; border:1px solid #262626; border-radius:12px; background:#101010; }
    .style-group-title { font-size:11px; letter-spacing:0.08em; text-transform:uppercase; opacity:0.6; margin-right:6px; }
    .help-panel { display:flex; flex-direction:column; gap:8px; max-width:420px; }
    .help-panel h3 { margin:0; font-size:14px; font-weight:600; }
    .help-panel ul { margin:0; padding-left:18px; font-size:12px; line-height:1.4; }
    .help-panel kbd { background:#151515; border:1px solid #333; border-radius:6px; padding:2px 6px; font-size:11px; }
    .hidden { display:none; }

    /* Log panel */
    #logWrap { padding:10px; border-top:1px solid #222; background:#0a0a0a; height:60px; min-height:60px; max-height:50vh; overflow:auto; resize:vertical; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; }
    #logWrap.hidden { display:none; }
    @media (max-width: 768px) {
      #menuPanel { padding:6px 8px; gap:6px; }
      .menu-row { padding:8px; gap:6px; border-radius:10px; max-height:calc(100vh - 16px); }
      .style-group { padding:6px 8px; gap:6px; }
      button, select, input { padding:4px 8px; border-radius:8px; }
      label { padding:4px 8px; border-radius:12px; gap:6px; }
      input[type="number"] { width:78px; }
      #logWrap { position:fixed; left:0; right:0; bottom:0; height:50vh; max-height:50vh; min-height:40vh; resize:none; z-index:12; box-shadow:0 -10px 24px rgba(0,0,0,0.45); }
    }
    .label { opacity:0.8; font-size:12px; }
    .ok { color:#9ad; }
    .warn { color:#da9; }
    .err { color:#f88; }
  </style>
</head>
<body>
  <div id="menuHeader">
    <button id="menuBtn" class="menu-toggle" aria-expanded="false" aria-label="Toggle menu">☰</button>
  </div>
  <div id="menuPanel" class="hidden" role="group" aria-label="Menu rows">
    <button class="menu-tab" data-row="source" aria-pressed="false">Source</button>
    <button class="menu-tab" data-row="behaviour" aria-pressed="false">Behaviour</button>
    <button class="menu-tab" data-row="style" aria-pressed="false">Style</button>
    <button class="menu-tab" data-row="log" aria-pressed="false">Log</button>
    <button class="menu-tab" data-row="help" aria-pressed="false" aria-label="Help">?</button>
  </div>
  <div id="top" class="menu-rows">
    <div id="row-source" class="menu-row hidden">
      <button id="micBtn">Mic</button>
      <button id="screenBtn">Screen/Tab audio</button>
      <button id="stopBtn" disabled>Stop</button>
    </div>
    <div id="row-behaviour" class="menu-row hidden">
      <button id="freezeBtn" class="menu-toggle">Freeze</button>
      <span class="label">View</span>
      <select id="viewSel" title="Spectrum view">
        <option value="third" selected>1/3-octave bars</option>
        <option value="autoOctave">1/x/auto-octave bars</option>
        <option value="fft">FFT line</option>
      </select>

      <span class="label">Scale</span>
      <select id="scaleSel" title="Frequency axis scaling">
        <option value="log" selected>Log</option>
        <option value="lin">Linear</option>
      </select>

      <span class="label">Min Hz</span>
      <input id="minHz" type="number" min="0.1" step="0.1" value="50" />

      <span class="label">Max Hz</span>
      <input id="maxHz" type="number" min="10" step="100" value="15000" />

      <span class="label">FFT</span>
      <select id="fftSel" title="FFT size (only affects FFT view)">
        <option>1024</option>
        <option selected>2048</option>
        <option>4096</option>
        <option>8192</option>
      </select>

      <div id="autoOctControls" class="auto-oct-controls hidden" title="1/x octaves plus auto density">
        <span class="label">1/x</span>
        <input id="octaveDivisor" type="number" min="1" max="24" step="1" value="3" />
        <label title="Automatically add more bars when the selected range is narrow">
          <input id="octaveAutoChk" type="checkbox" />
          <span>Auto</span>
        </label>
      </div>

      <span class="label">Smoothing</span>
      <input id="smooth" type="range" min="0" max="0.999" step="0.001" value="0.65" />

      <span class="label">dB range</span>
      <select id="dbSel">
        <option value="-90,-20" selected>-90..-20</option>
        <option value="-80,-20">-80..-20</option>
        <option value="-70,-10">-70..-10</option>
      </select>

      <div class="peak-section">
        <label title="Hold peaks until reset">
          <input id="peakHoldChk" type="checkbox" />
          <span>Peek hold</span>
        </label>
        <button id="peakResetBtn" type="button">Reset peaks</button>
      </div>
      <label title="Load/save preset banks">
        <span>Presets</span>
        <select id="bankSel">
          <option value="">Banks</option>
          <option value="default">Defaults / Reset</option>
          <option value="bank-1-load">Load bank 1</option>
          <option value="bank-2-load">Load bank 2</option>
          <option value="bank-3-load">Load bank 3</option>
          <option value="bank-1-save">Save to bank 1</option>
          <option value="bank-2-save">Save to bank 2</option>
          <option value="bank-3-save">Save to bank 3</option>
        </select>
      </label>
    </div>
    <div id="row-style" class="menu-row hidden">
      <div class="style-block" title="Visual style and color presets">
        <label title="Style presets">
          <span>Style</span>
          <select id="stylePreset">
            <option value="" selected>Presets</option>
            <optgroup label="Bars gradient LR">
              <option value="bars-gradient-lr-light">Bars LR light</option>
              <option value="bars-gradient-lr-dark">Bars LR dark</option>
            </optgroup>
            <optgroup label="Bars gradient UD">
              <option value="bars-gradient-ud-light">Bars UD light</option>
              <option value="bars-gradient-ud-dark">Bars UD dark</option>
            </optgroup>
            <optgroup label="FFT palette">
              <option value="fft-light">FFT light</option>
              <option value="fft-dark">FFT dark</option>
            </optgroup>
            <optgroup label="Background">
              <option value="bg-light">Background light</option>
              <option value="bg-dark">Background dark</option>
            </optgroup>
            <option value="style-reset">Reset defaults</option>
          </select>
        </label>
        <div class="style-submenu">
          <div class="style-group">
            <span class="style-group-title">Bars</span>
            <label title="Bar base color">
              <span>Bar color</span>
              <input id="barColor" type="color" value="#d0d0d0" />
            </label>
            <label title="Bar gradient start">
              <span>Bar gradient start</span>
              <input id="barGradientStart" type="color" value="#d0d0d0" />
            </label>
            <label title="Bar gradient end">
              <span>Bar gradient end</span>
              <input id="barGradientEnd" type="color" value="#d0d0d0" />
            </label>
            <label title="Bar gradient orientation">
              <span>Bar gradient dir</span>
              <select id="barGradientDir">
                <option value="lr" selected>Left → Right</option>
                <option value="ud">Top → Bottom</option>
              </select>
            </label>
            <label title="Bar outline width">
              <span>Bar width</span>
              <input id="barLineWidth" type="number" min="0" step="0.5" value="0" />
            </label>
          </div>
          <div class="style-group">
            <span class="style-group-title">FFT</span>
            <label title="FFT line color">
              <span>FFT color</span>
              <input id="fftLineColor" type="color" value="#d0d0d0" />
            </label>
            <label title="FFT line width">
              <span>FFT width</span>
              <input id="fftLineWidth" type="number" min="0.5" step="0.5" value="2" />
            </label>
          </div>
          <div class="style-group">
            <span class="style-group-title">Grid</span>
            <label title="Show grid">
              <input id="gridShowChk" type="checkbox" checked />
              <span>Grid display</span>
            </label>
            <label title="Show Hz labels on grid lines">
              <input id="labelsChk" type="checkbox" checked />
              <span>Hz labels</span>
            </label>
            <label title="Grid color">
              <span>Grid color</span>
              <input id="gridColor" type="color" value="#1f1f1f" />
            </label>
            <label title="Grid line width">
              <span>Grid width</span>
              <input id="gridLineWidth" type="number" min="0.5" step="0.5" value="1" />
            </label>
          </div>
          <div class="style-group">
            <span class="style-group-title">Background</span>
            <label title="Background color">
              <span>BG color</span>
              <input id="bgColor" type="color" value="#0b0b0b" />
            </label>
            <label title="Background gradient start">
              <span>BG gradient start</span>
              <input id="bgGradientStart" type="color" value="#0b0b0b" />
            </label>
            <label title="Background gradient end">
              <span>BG gradient end</span>
              <input id="bgGradientEnd" type="color" value="#141414" />
            </label>
            <label title="Background gradient orientation">
              <span>BG gradient dir</span>
              <select id="bgGradientDir">
                <option value="lr" selected>Left → Right</option>
                <option value="ud">Top → Bottom</option>
              </select>
            </label>
          </div>
        </div>
      </div>
    </div>
    <div id="row-log" class="menu-row hidden">
      <label title="Show/hide error log panel">
        <input id="logChk" type="checkbox" />
        <span>Log</span>
      </label>
    </div>
    <div id="row-help" class="menu-row hidden">
      <div class="help-panel">
        <h3>Quick help</h3>
        <ul>
          <li><kbd>Space</kbd> Freeze / resume</li>
          <li><kbd>1</kbd> <kbd>2</kbd> <kbd>3</kbd> Load preset bank</li>
          <li><kbd>←</kbd> / <kbd>→</kbd> Adjust Max Hz</li>
          <li><kbd>↑</kbd> / <kbd>↓</kbd> Adjust Min Hz</li>
          <li><kbd>L</kbd> Cycle view (1/3-oct, 1/x-oct, FFT)</li>
          <li><kbd>F</kbd> Freeze / resume</li>
          <li><kbd>R</kbd> Reset peaks</li>
          <li><kbd>P</kbd> Toggle peak hold</li>
          <li><kbd>G</kbd> Toggle grid</li>
          <li><kbd>H</kbd> Toggle Hz labels</li>
          <li><kbd>M</kbd> Mic input</li>
          <li><kbd>T</kbd> Screen/tab audio</li>
          <li><kbd>S</kbd> Stop</li>
        </ul>
      </div>
    </div>
  </div>

  <canvas id="c"></canvas>
  <div id="logWrap"></div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx2d = canvas.getContext('2d', { alpha: false });

  const micBtn = document.getElementById('micBtn');
  const screenBtn = document.getElementById('screenBtn');
  const stopBtn = document.getElementById('stopBtn');

  const viewSel = document.getElementById('viewSel');   // 'third' | 'fft'
  const scaleSel = document.getElementById('scaleSel'); // 'log' | 'lin'
  const labelsChk = document.getElementById('labelsChk');

  const minHzEl = document.getElementById('minHz');
  const maxHzEl = document.getElementById('maxHz');

  const fftSel = document.getElementById('fftSel');
  const smooth = document.getElementById('smooth');
  const dbSel = document.getElementById('dbSel');

  const autoOctControls = document.getElementById('autoOctControls');
  const octaveDivisorEl = document.getElementById('octaveDivisor');
  const octaveAutoChk = document.getElementById('octaveAutoChk');
  const menuBtn = document.getElementById('menuBtn');
  const menuPanel = document.getElementById('menuPanel');
  const menuTabs = menuPanel ? Array.from(menuPanel.querySelectorAll('.menu-tab')) : [];
  const menuRows = {
    source: document.getElementById('row-source'),
    behaviour: document.getElementById('row-behaviour'),
    style: document.getElementById('row-style'),
    log: document.getElementById('row-log'),
    help: document.getElementById('row-help')
  };
  const freezeBtn = document.getElementById('freezeBtn');
  const tooltip = document.createElement('div');
  tooltip.className = 'tooltip hidden';
  document.body.appendChild(tooltip);
  const peakHoldChk = document.getElementById('peakHoldChk');
  const peakResetBtn = document.getElementById('peakResetBtn');

  const logChk = document.getElementById('logChk');
  const logWrap = document.getElementById('logWrap');
  const bankSel = document.getElementById('bankSel');
  const stylePresetSel = document.getElementById('stylePreset');
  const barColorPicker = document.getElementById('barColor');
  const barGradientStartPicker = document.getElementById('barGradientStart');
  const barGradientEndPicker = document.getElementById('barGradientEnd');
  const barGradientDirSel = document.getElementById('barGradientDir');
  const barLineWidthInput = document.getElementById('barLineWidth');
  const fftLineColorPicker = document.getElementById('fftLineColor');
  const fftLineWidthInput = document.getElementById('fftLineWidth');
  const gridShowChk = document.getElementById('gridShowChk');
  const gridColorPicker = document.getElementById('gridColor');
  const gridLineWidthInput = document.getElementById('gridLineWidth');
  const bgColorPicker = document.getElementById('bgColor');
  const bgGradientStartPicker = document.getElementById('bgGradientStart');
  const bgGradientEndPicker = document.getElementById('bgGradientEnd');
  const bgGradientDirSel = document.getElementById('bgGradientDir');

  const BANK_STORAGE_PREFIX = 'rta-bank-';
  const DEFAULT_BANKS = {
    1: {
      view: 'autoOctave',
      scale: 'log',
      labels: true,
      minHz: '60',
      maxHz: '12000',
      fft: '8192',
      smoothing: '0.853',
      dbRange: '-80,-20',
      octaveDivisor: '8',
      octaveAuto: false,
      log: false,
      peakHold: false
    },
    2: {
      view: 'autoOctave',
      scale: 'log',
      labels: true,
      minHz: '56',
      maxHz: '12000',
      fft: '2048',
      smoothing: '0.853',
      dbRange: '-90,-20',
      octaveDivisor: '3',
      octaveAuto: false,
      log: false,
      peakHold: false,
      backgroundColor: '#000000',
      backgroundGradientDir: 'ud',
      backgroundGradientEnd: '#800000',
      backgroundGradientStart: '#000000',
      barColor: '#9a88ff',
      barGradientDir: 'ud',
      barGradientEnd: '#3900f5',
      barGradientStart: '#00c24a',
      barLineWidth: 10,
      fftLineColor: '#d0d0d0',
      fftLineWidth: 2,
      gridColor: '#f31212',
      gridLineWidth: 1,
      gridShow: true
    },
    3: {
      view: 'fft',
      scale: 'log',
      labels: true,
      minHz: '80',
      maxHz: '10000',
      fft: '2048',
      smoothing: '0.921',
      dbRange: '-90,-20',
      octaveDivisor: '3',
      octaveAuto: false,
      log: false,
      peakHold: true,
      backgroundColor: '#000000',
      backgroundGradientDir: 'ud',
      backgroundGradientEnd: '#000000',
      backgroundGradientStart: '#000000',
      barColor: '#9a88ff',
      barGradientDir: 'ud',
      barGradientEnd: '#3900f5',
      barGradientStart: '#00c24a',
      barLineWidth: 10,
      fftLineColor: '#ff00bb',
      fftLineWidth: 4,
      gridColor: '#f31212',
      gridLineWidth: 0.5,
      gridShow: true
    }
  };
  const STYLE_DEFAULTS = {
    barColor: '#d0d0d0',
    barGradientStart: '#d0d0d0',
    barGradientEnd: '#d0d0d0',
    barGradientDir: 'lr',
    barLineWidth: 0,
    fftLineColor: '#d0d0d0',
    fftLineWidth: 2,
    gridColor: '#1f1f1f',
    gridLineWidth: 1,
    gridShow: true,
    backgroundColor: '#0b0b0b',
    backgroundGradientStart: '#0b0b0b',
    backgroundGradientEnd: '#141414',
    backgroundGradientDir: 'lr'
  };
  const DEFAULT_SETTINGS = {
    view: 'third',
    scale: 'log',
    labels: true,
    minHz: 50,
    maxHz: 15000,
    fft: '2048',
    smoothing: '0.65',
    dbRange: '-90,-20',
    octaveDivisor: '3',
    octaveAuto: false,
    log: false,
    peakHold: false,
    gridShow: true,
    ...STYLE_DEFAULTS
  };
  const STYLE_PRESETS = {
    'bars-gradient-lr-light': {
      barGradientDir: 'lr',
      barGradientStart: '#ffe29a',
      barGradientEnd: '#ff6a6a',
      barColor: '#ffb347'
    },
    'bars-gradient-lr-dark': {
      barGradientDir: 'lr',
      barGradientStart: '#7163dd',
      barGradientEnd: '#221747',
      barColor: '#9a88ff'
    },
    'bars-gradient-ud-light': {
      barGradientDir: 'ud',
      barGradientStart: '#fdf0bb',
      barGradientEnd: '#f5736c',
      barColor: '#ff9b5a'
    },
    'bars-gradient-ud-dark': {
      barGradientDir: 'ud',
      barGradientStart: '#2e3192',
      barGradientEnd: '#1b1f4b',
      barColor: '#4b52c1'
    },
    'fft-light': {
      fftLineColor: '#d7f8ff',
      fftLineWidth: 3
    },
    'fft-dark': {
      fftLineColor: '#ffa5ff',
      fftLineWidth: 3
    },
    'bg-light': {
      backgroundColor: '#f6f7fb',
      backgroundGradientStart: '#ffffff',
      backgroundGradientEnd: '#d4ddff',
      backgroundGradientDir: 'lr'
    },
    'bg-dark': {
      backgroundColor: '#05050a',
      backgroundGradientStart: '#010101',
      backgroundGradientEnd: '#12121f',
      backgroundGradientDir: 'lr'
    }
  };

  let ac = null, analyser = null, src = null;
  let stream = null;       // original (may contain video)
  let audioStream = null;  // audio-only stream used by WebAudio
  let raf = 0;
  let data = null;

  let bandsCacheKey = '';
  let bands = []; // [{fc, f1, f2, label}...]
  let peakHoldEnabled = false;
  let fftPeaks = null;
  let bandPeaks = null;
  let isFrozen = false;
  const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

  // ---------- Logging ----------
  function nowStr() {
    const d = new Date();
    const pad = (n, w=2) => String(n).padStart(w, '0');
    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}.${pad(d.getMilliseconds(),3)}`;
  }
  function log(msg, cls='ok') {
    if (!logWrap) return;
    const div = document.createElement('div');
    div.className = cls;
    div.textContent = `[${nowStr()}] ${msg}`;
    logWrap.appendChild(div);
    // keep last ~200 lines
    while (logWrap.childNodes.length > 200) logWrap.removeChild(logWrap.firstChild);
    logWrap.scrollTop = logWrap.scrollHeight;
  }
  function logErr(prefix, e) {
    const msg = e && e.message ? `${prefix}: ${e.message}` : `${prefix}: ${String(e)}`;
    log(msg, 'err');
    if (e && e.stack) log(e.stack, 'err');
  }

  window.addEventListener('error', (ev) => {
    log(`window.onerror: ${ev.message} @ ${ev.filename}:${ev.lineno}:${ev.colno}`, 'err');
    if (ev.error && ev.error.stack) log(ev.error.stack, 'err');
  });
  window.addEventListener('unhandledrejection', (ev) => {
    logErr('unhandledrejection', ev.reason);
  });

  function updateLogVisibility() {
    if (!logWrap) return;
    const shouldShow = !!(logChk && logChk.checked);
    logWrap.classList.toggle('hidden', !shouldShow);
    document.body.classList.toggle('log-open', shouldShow);
  }

  logChk.addEventListener('change', updateLogVisibility);

  function updateFreezeButton() {
    if (!freezeBtn) return;
    freezeBtn.textContent = isFrozen ? 'Resume' : 'Freeze';
  }

  function setFreezeState(enabled) {
    isFrozen = !!enabled;
    updateFreezeButton();
  }

  if (freezeBtn) {
    freezeBtn.addEventListener('click', () => setFreezeState(!isFrozen));
  }

  // ---------- Resize ----------
  function resize() {
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    canvas.width  = Math.floor(canvas.clientWidth  * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);
  }
  window.addEventListener('resize', resize);
  function logViewportStats(label) {
    const vv = window.visualViewport;
    const orientation = screen.orientation ? `${screen.orientation.type} ${screen.orientation.angle}` : 'unknown';
    const client = `${Math.round(document.documentElement.clientWidth)}x${Math.round(document.documentElement.clientHeight)}`;
    const inner = `${Math.round(window.innerWidth)}x${Math.round(window.innerHeight)}`;
    const canvasRect = canvas.getBoundingClientRect();
    const canvasSize = `${Math.round(canvasRect.width)}x${Math.round(canvasRect.height)}`;
    const vvSize = vv ? `${Math.round(vv.width)}x${Math.round(vv.height)} scale=${vv.scale.toFixed(2)}` : 'n/a';
    log(`${label} | orientation=${orientation} | client=${client} | inner=${inner} | canvas=${canvasSize} | vv=${vvSize}`, 'warn');
  }

  window.addEventListener('orientationchange', () => {
    logViewportStats('orientationchange');
    window.setTimeout(() => {
      resize();
      logViewportStats('orientationchange+50ms');
    }, 50);
  });
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', () => {
      logViewportStats('visualViewport.resize');
      window.setTimeout(() => {
        resize();
        logViewportStats('visualViewport.resize+0ms');
      }, 0);
    });
  }
  resize();

  function hideTooltip() {
    if (tooltip) tooltip.classList.add('hidden');
  }

  function handleCanvasHover(ev) {
    if (!ac || viewSel.value === 'fft') { hideTooltip(); return; }
    const rect = canvas.getBoundingClientRect();
    if (!rect.width) { hideTooltip(); return; }
    const x = clamp(ev.clientX - rect.left, 0, rect.width);
    const logicalX = (x / rect.width) * canvas.width;
    const freq = xToHz(logicalX, ac.sampleRate, canvas.width);
    if (!Number.isFinite(freq) || freq <= 0) { hideTooltip(); return; }
    tooltip.textContent = `${freqToNoteLabel(freq)} ${fmtHz(freq)}Hz`;
    tooltip.style.left = `${ev.clientX}px`;
    tooltip.style.top = `${ev.clientY - 10}px`;
    tooltip.classList.remove('hidden');
  }

  canvas.addEventListener('mousemove', handleCanvasHover);
  canvas.addEventListener('mouseleave', hideTooltip);

  function updateAutoOctControlsVisibility() {
    if (!autoOctControls) return;
    const show = viewSel.value === 'autoOctave';
    autoOctControls.classList.toggle('hidden', !show);
  }

  function ensureFftPeaks(count) {
    if (!fftPeaks || fftPeaks.length !== count) {
      fftPeaks = new Float32Array(count);
    }
  }

  function ensureBandPeaks(count) {
    if (!bandPeaks || bandPeaks.length !== count) {
      bandPeaks = new Float32Array(count);
    }
  }

  function resetPeakHoldData() {
    fftPeaks = null;
    bandPeaks = null;
  }

  function setPeakHold(value) {
    peakHoldEnabled = !!value;
    if (!peakHoldEnabled) resetPeakHoldData();
  }

  function getStyleConfig() {
    const parseNumber = (el, fallback) => {
      if (!el) return fallback;
      const parsed = Number(el.value);
      return Number.isFinite(parsed) ? parsed : fallback;
    };
    return {
      barColor: barColorPicker ? barColorPicker.value : DEFAULT_SETTINGS.barColor,
      barGradientStart: barGradientStartPicker ? barGradientStartPicker.value : DEFAULT_SETTINGS.barGradientStart,
      barGradientEnd: barGradientEndPicker ? barGradientEndPicker.value : DEFAULT_SETTINGS.barGradientEnd,
      barGradientDir: barGradientDirSel ? barGradientDirSel.value : DEFAULT_SETTINGS.barGradientDir,
      barLineWidth: parseNumber(barLineWidthInput, DEFAULT_SETTINGS.barLineWidth),
      fftLineColor: fftLineColorPicker ? fftLineColorPicker.value : DEFAULT_SETTINGS.fftLineColor,
      fftLineWidth: parseNumber(fftLineWidthInput, DEFAULT_SETTINGS.fftLineWidth),
      gridShow: gridShowChk ? gridShowChk.checked : DEFAULT_SETTINGS.gridShow,
      gridColor: gridColorPicker ? gridColorPicker.value : DEFAULT_SETTINGS.gridColor,
      gridLineWidth: parseNumber(gridLineWidthInput, DEFAULT_SETTINGS.gridLineWidth),
      backgroundColor: bgColorPicker ? bgColorPicker.value : DEFAULT_SETTINGS.backgroundColor,
      backgroundGradientStart: bgGradientStartPicker ? bgGradientStartPicker.value : DEFAULT_SETTINGS.backgroundGradientStart,
      backgroundGradientEnd: bgGradientEndPicker ? bgGradientEndPicker.value : DEFAULT_SETTINGS.backgroundGradientEnd,
      backgroundGradientDir: bgGradientDirSel ? bgGradientDirSel.value : DEFAULT_SETTINGS.backgroundGradientDir
    };
  }

  function getCurrentSettings() {
    const style = getStyleConfig();
    return {
      view: viewSel.value,
      scale: scaleSel.value,
      labels: labelsChk.checked,
      minHz: minHzEl.value || DEFAULT_SETTINGS.minHz,
      maxHz: maxHzEl.value || DEFAULT_SETTINGS.maxHz,
      fft: fftSel.value,
      smoothing: smooth.value,
      dbRange: dbSel.value,
      octaveDivisor: octaveDivisorEl.value,
      octaveAuto: octaveAutoChk.checked,
      log: logChk.checked,
      peakHold: peakHoldChk ? peakHoldChk.checked : false,
      ...style
    };
  }

  function applyStyleValues(values = {}) {
    const current = getStyleConfig();
    const cfg = { ...current, ...values };
    if (barColorPicker) barColorPicker.value = cfg.barColor;
    if (barGradientStartPicker) barGradientStartPicker.value = cfg.barGradientStart;
    if (barGradientEndPicker) barGradientEndPicker.value = cfg.barGradientEnd;
    if (barGradientDirSel) barGradientDirSel.value = cfg.barGradientDir;
    if (barLineWidthInput) barLineWidthInput.value = String(cfg.barLineWidth);
    if (fftLineColorPicker) fftLineColorPicker.value = cfg.fftLineColor;
    if (fftLineWidthInput) fftLineWidthInput.value = String(cfg.fftLineWidth);
    if (gridShowChk) gridShowChk.checked = !!cfg.gridShow;
    if (gridColorPicker) gridColorPicker.value = cfg.gridColor;
    if (gridLineWidthInput) gridLineWidthInput.value = String(cfg.gridLineWidth);
    if (bgColorPicker) bgColorPicker.value = cfg.backgroundColor;
    if (bgGradientStartPicker) bgGradientStartPicker.value = cfg.backgroundGradientStart;
    if (bgGradientEndPicker) bgGradientEndPicker.value = cfg.backgroundGradientEnd;
    if (bgGradientDirSel) bgGradientDirSel.value = cfg.backgroundGradientDir;
    if (stylePresetSel) stylePresetSel.value = '';
    refreshStylePreview();
  }

  function applySettings(settings) {
    const cfg = { ...DEFAULT_SETTINGS, ...settings };
    viewSel.value = cfg.view;
    scaleSel.value = cfg.scale;
    labelsChk.checked = !!cfg.labels;
    minHzEl.value = String(cfg.minHz);
    maxHzEl.value = String(cfg.maxHz);
    fftSel.value = cfg.fft;
    smooth.value = String(cfg.smoothing);
    dbSel.value = cfg.dbRange;
    if (octaveDivisorEl) octaveDivisorEl.value = String(cfg.octaveDivisor);
    if (octaveAutoChk) octaveAutoChk.checked = !!cfg.octaveAuto;
    logChk.checked = !!cfg.log;
    applyStyleValues(cfg);
    updateLogVisibility();
    if (peakHoldChk) {
      peakHoldChk.checked = !!cfg.peakHold;
      setPeakHold(peakHoldChk.checked);
    }
    if (analyser) setupAnalyser();
    viewSel.dispatchEvent(new Event('change'));
  }

  function ensureDefaultBanks() {
    if (typeof localStorage === 'undefined') return;
    try {
      Object.keys(DEFAULT_BANKS).forEach((key) => {
        const bankNum = Number(key);
        if (!Number.isFinite(bankNum)) return;
        const storageKey = `${BANK_STORAGE_PREFIX}${bankNum}`;
        if (!localStorage.getItem(storageKey)) {
          localStorage.setItem(storageKey, JSON.stringify(DEFAULT_BANKS[bankNum]));
        }
      });
    } catch (e) {
      logErr('Default bank init failed', e);
    }
  }

  function saveBank(bankNum) {
    if (typeof localStorage === 'undefined') {
      log('localStorage unavailable; cannot save bank', 'warn');
      return;
    }
    try {
      localStorage.setItem(`${BANK_STORAGE_PREFIX}${bankNum}`, JSON.stringify(getCurrentSettings()));
      log(`Saved settings to bank ${bankNum}`, 'ok');
    } catch (e) {
      logErr('Saving bank failed', e);
    }
  }

  function loadBank(bankNum) {
    if (typeof localStorage === 'undefined') {
      log('localStorage unavailable; cannot load bank', 'warn');
      return;
    }
    const serialized = localStorage.getItem(`${BANK_STORAGE_PREFIX}${bankNum}`);
    if (!serialized) {
      log(`Bank ${bankNum} is empty`, 'warn');
      return;
    }
    try {
      const data = JSON.parse(serialized);
      applySettings(data);
      log(`Loaded settings from bank ${bankNum}`, 'ok');
    } catch (e) {
      logErr('Loading bank failed', e);
    }
  }

  function handleBankAction(action) {
    if (!action) return;
    if (action === 'default') {
      applySettings(DEFAULT_SETTINGS);
      log('Applied default settings', 'ok');
      return;
    }
    const [bankLabel, bankNum, op] = action.split('-');
    if (bankLabel !== 'bank') return;
    const num = Number(bankNum);
    if (!Number.isFinite(num) || num < 1 || num > 3) return;
    if (op === 'save') saveBank(num);
    else if (op === 'load') loadBank(num);
  }

  if (peakHoldChk) {
    peakHoldChk.addEventListener('change', () => setPeakHold(peakHoldChk.checked));
  }
  if (peakResetBtn) {
    peakResetBtn.addEventListener('click', () => resetPeakHoldData());
  }

  const MENU_ANIM_MS = 160;
  let lastVisibleRows = ['source'];

  function isMobileLayout() {
    return window.matchMedia('(max-width: 768px)').matches;
  }

  function positionMenuPanel() {
    if (!menuPanel || !menuBtn) return;
    const btnRect = menuBtn.getBoundingClientRect();
    const maxLeft = Math.max(8, window.innerWidth - menuPanel.offsetWidth - 8);
    const left = Math.min(btnRect.right + 8, maxLeft);
    menuPanel.style.top = `${Math.round(btnRect.top)}px`;
    menuPanel.style.left = `${Math.round(left)}px`;
  }

  function getVisibleRowKeys() {
    return Object.keys(menuRows).filter(key => {
      const row = menuRows[key];
      return row && !row.classList.contains('hidden');
    });
  }

  function positionOpenRows() {
    if (!menuPanel || !menuBtn) return;
    const visibleKeys = getVisibleRowKeys();
    if (!visibleKeys.length) return;
    const btnRect = menuBtn.getBoundingClientRect();
    const panelRect = menuPanel.getBoundingClientRect();
    let maxWidth = 0;
    visibleKeys.forEach(key => {
      const row = menuRows[key];
      if (!row) return;
      row.style.maxWidth = `${Math.max(220, window.innerWidth - 16)}px`;
      maxWidth = Math.max(maxWidth, row.offsetWidth);
    });
    const rightSpace = window.innerWidth - panelRect.right - 8;
    const stackRight = rightSpace >= maxWidth;
    let currentTop = stackRight ? panelRect.top : btnRect.bottom + 8;
    const left = stackRight ? Math.round(panelRect.right + 8) : 8;
    visibleKeys.forEach(key => {
      const row = menuRows[key];
      if (!row) return;
      row.style.left = `${left}px`;
      row.style.top = `${Math.round(currentTop)}px`;
      const maxHeight = Math.max(120, window.innerHeight - currentTop - 8);
      row.style.maxHeight = `${Math.round(maxHeight)}px`;
      currentTop += row.offsetHeight + 8;
    });
  }

  function setRowVisible(key, visible) {
    const row = menuRows[key];
    if (!row) return;
    const tab = menuTabs.find(btn => btn.dataset.row === key);
    if (visible) {
      row.classList.remove('hidden');
      requestAnimationFrame(() => {
        positionOpenRows();
        row.classList.add('open');
      });
    } else {
      row.classList.remove('open');
      window.setTimeout(() => {
        row.classList.add('hidden');
        positionOpenRows();
      }, MENU_ANIM_MS);
    }
    if (tab) {
      tab.classList.toggle('active', visible);
      tab.setAttribute('aria-pressed', String(visible));
    }
  }

  function hideAllRows() {
    Object.keys(menuRows).forEach(key => setRowVisible(key, false));
  }

  function setMenuCollapsedState(collapsed) {
    document.body.classList.toggle('menu-collapsed', !!collapsed);
  }

  function toggleMenuPanel(forceState) {
    if (!menuPanel) return;
    const shouldShow = typeof forceState === 'boolean'
      ? forceState
      : menuPanel.classList.contains('hidden');
    if (shouldShow) {
      menuPanel.classList.remove('hidden');
      positionMenuPanel();
      requestAnimationFrame(() => menuPanel.classList.add('open'));
      setMenuCollapsedState(false);
      const restoreKeys = lastVisibleRows.length ? lastVisibleRows : [];
      const keysToShow = isMobileLayout() && restoreKeys.length ? [restoreKeys[0]] : restoreKeys;
      keysToShow.forEach(key => setRowVisible(key, true));
    } else {
      lastVisibleRows = getVisibleRowKeys();
      menuPanel.classList.remove('open');
      window.setTimeout(() => menuPanel.classList.add('hidden'), MENU_ANIM_MS);
      hideAllRows();
      setMenuCollapsedState(true);
    }
    if (menuBtn) menuBtn.setAttribute('aria-expanded', String(shouldShow));
  }

  if (menuBtn) {
    menuBtn.addEventListener('click', () => toggleMenuPanel());
  }

  if (menuTabs.length) {
    menuTabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const key = tab.dataset.row;
        const row = key ? menuRows[key] : null;
        if (!row) return;
        const willShow = row.classList.contains('hidden');
        if (isMobileLayout() && willShow) {
          Object.keys(menuRows).forEach(otherKey => {
            if (otherKey !== key) setRowVisible(otherKey, false);
          });
        }
        setRowVisible(key, willShow);
      });
    });
  }

  window.addEventListener('resize', () => {
    if (!menuPanel || menuPanel.classList.contains('hidden')) return;
    positionMenuPanel();
    const visibleKeys = getVisibleRowKeys();
    if (isMobileLayout() && visibleKeys.length > 1) {
      visibleKeys.slice(1).forEach(key => setRowVisible(key, false));
    }
    positionOpenRows();
  });

  // ---------- Helpers ----------
  function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }

  function buildDirectionalGradient(start, end, dir, width, height, fallback) {
    const from = start || fallback;
    const to = end || from;
    if (!from || !to) return fallback || from;
    if (from === to) return from;
    if (!width || !height) return from;
    const gradient = dir === 'ud'
      ? ctx2d.createLinearGradient(0, 0, 0, height)
      : ctx2d.createLinearGradient(0, 0, width, 0);
    gradient.addColorStop(0, from);
    gradient.addColorStop(1, to);
    return gradient;
  }

  function getHzLimits(sampleRate) {
  const nyq = sampleRate / 2;

  let minHz = Number(minHzEl.value);
  let maxHz = Number(maxHzEl.value);

  if (!Number.isFinite(minHz)) minHz = 10;
  if (!Number.isFinite(maxHz)) maxHz = 20000;

  // absolute bounds
  const absMin = 0.1;
  minHz = clamp(minHz, absMin, nyq);
  maxHz = clamp(maxHz, 10, nyq);

  if (maxHz <= minHz) {
    const gap = Math.max(1, minHz * 0.05);
    maxHz = Math.min(nyq, minHz + gap);
    if (maxHz <= minHz) maxHz = Math.min(nyq, minHz + 1);
  }

  return { minHz, maxHz, nyq };
  }

  function hzToX(hz, sampleRate, w) {
    const { minHz, maxHz } = getHzLimits(sampleRate);
    const mode = scaleSel.value; // 'log' or 'lin'

    const f = clamp(hz, minHz, maxHz);

    if (mode === 'lin') {
      const t = (f - minHz) / (maxHz - minHz);
      return t * w;
    }

    // true log mapping with absolute min allowed (>= 0.1 Hz)
    const fMin = Math.max(0.1, minHz);
    const fMax = Math.max(fMin * 1.001, maxHz);

    const a = Math.log10(f);
    const b = Math.log10(fMax);
    const c = Math.log10(fMin);
    return (a - c) / (b - c) * w;
  }

  function xToHz(x, sampleRate, w) {
    const { minHz, maxHz } = getHzLimits(sampleRate);
    const mode = scaleSel.value;
    const ratio = clamp(x / w, 0, 1);
    if (mode === 'lin') {
      return minHz + ratio * (maxHz - minHz);
    }

    const fMin = Math.max(0.1, minHz);
    const fMax = Math.max(fMin * 1.001, maxHz);
    const logMin = Math.log10(fMin);
    const logMax = Math.log10(fMax);
    const logF = logMin + ratio * (logMax - logMin);
    return Math.pow(10, logF);
  }

  function gridFrequencies(sampleRate) {
    const { minHz, maxHz } = getHzLimits(sampleRate);
    const base = [10, 20, 30, 50, 80, 100, 200, 300, 500, 800, 1000, 1500, 2000, 3000, 5000, 8000, 10000, 15000, 20000];
    return base.filter(f => f >= minHz && f <= maxHz);
  }

  function buildOctaveBands(sampleRate, divisor) {
    const { minHz, maxHz, nyq } = getHzLimits(sampleRate);
    const key = `${sampleRate}|${minHz}|${maxHz}|${nyq}|${analyser ? analyser.fftSize : 0}|${divisor}`;
    if (bandsCacheKey === key) return bands;
    bandsCacheKey = key;

    const r = Math.pow(2, 1 / divisor);
    const edge = Math.pow(2, 1 / (divisor * 2));
    let fc = 1000;

    while (fc > Math.max(minHz, 1e-3)) fc /= r;
    while (fc < Math.max(minHz, 1e-3)) fc *= r;

    const out = [];
    for (; fc <= maxHz * 1.0001; fc *= r) {
      const f1 = fc / edge;
      const f2 = fc * edge;

      if (f2 < minHz) continue;
      if (f1 > maxHz) break;
      if (f1 >= nyq) break;

      out.push({
        fc,
        f1: Math.max(f1, minHz),
        f2: Math.min(f2, Math.min(maxHz, nyq)),
        label: fmtHz(fc)
      });
    }
    bands = out;
    return bands;
  }

  function buildThirdOctaveBands(sampleRate) {
    return buildOctaveBands(sampleRate, 3);
  }

  function resolveOctaveDivisor(minHz, maxHz) {
    let divisor = parseInt(octaveDivisorEl.value, 10);
    if (!Number.isFinite(divisor) || divisor < 1) divisor = 1;
    divisor = Math.min(24, divisor);

    if (octaveAutoChk && octaveAutoChk.checked) {
      const range = Math.max(1, maxHz - minHz);
      const boost = Math.max(0, Math.round(Math.log2(10000 / range)));
      const autoTarget = Math.min(24, 3 + boost);
      divisor = Math.max(divisor, autoTarget);
    }

    return divisor;
  }

  function fmtHz(hz, opts = {}) {
    const roundTo = Math.max(1, opts.roundTo || 1);
    const rounded = Math.max(roundTo, Math.round(hz / roundTo) * roundTo);
    if (rounded >= 1000) {
      const k = rounded / 1000;
      const s = (Math.round(k * 10) / 10).toString();
      return s.endsWith('.0') ? `${s.slice(0,-2)}k` : `${s}k`;
    }
    return `${rounded}`;
  }

  function freqToNoteLabel(freq) {
    if (!Number.isFinite(freq) || freq <= 0) return '??';
    const ratio = freq / 440;
    const log2 = typeof Math.log2 === 'function' ? Math.log2(ratio) : Math.log(ratio) / Math.LN2;
    const note = Math.round(69 + 12 * log2);
    const octave = Math.floor(note / 12) - 1;
    const idx = ((note % 12) + 12) % 12;
    return `${NOTES[idx]}${octave}`;
  }

  function binToHz(i, binCount, sampleRate) {
    const nyq = sampleRate / 2;
    return (i / binCount) * nyq;
  }

  function bandLevel01(band, sampleRate) {
    if (!data || !data.length) return 0;

    const binCount = data.length;
    const nyq = sampleRate / 2;

    const f1 = clamp(band.f1, 0, nyq);
    const f2 = clamp(band.f2, 0, nyq);
    if (f2 <= f1) return 0;

    // map to bins
    const i1 = Math.floor((f1 / nyq) * binCount);
    const i2 = Math.ceil((f2 / nyq) * binCount);

    const a = clamp(i1, 0, binCount - 1);
    const b = clamp(i2, 0, binCount);

    let sum = 0;
    let n = 0;
    for (let i = a; i < b; i++) { sum += data[i]; n++; }
    if (n === 0) return 0;
    return (sum / n) / 255;
  }

  // ---------- Audio setup ----------
  function setupAnalyser() {
    if (!analyser) return;
    analyser.fftSize = parseInt(fftSel.value, 10);
    analyser.smoothingTimeConstant = parseFloat(smooth.value);
    const [minDb, maxDb] = dbSel.value.split(',').map(Number);
    analyser.minDecibels = minDb;
    analyser.maxDecibels = maxDb;
    data = new Uint8Array(analyser.frequencyBinCount);
    bandsCacheKey = '';
    log(`Analyser: fftSize=${analyser.fftSize}, bins=${analyser.frequencyBinCount}`, 'ok');
  }

  function attachStreamEndHandlers(s, label) {
    if (!s) return;
    const tracks = s.getTracks();
    tracks.forEach(t => {
      t.addEventListener('ended', () => {
        log(`${label} track ended (${t.kind}) -> stopping`, 'warn');
        stop();
      });
    });
  }

  function stop() {
    try { cancelAnimationFrame(raf); } catch {}
    raf = 0;

    if (src) { try { src.disconnect(); } catch {} }
    if (analyser) { try { analyser.disconnect(); } catch {} }
    src = null;
    analyser = null;

    if (audioStream) { try { audioStream.getTracks().forEach(t => t.stop()); } catch {} }
    audioStream = null;

    if (stream) { try { stream.getTracks().forEach(t => t.stop()); } catch {} }
    stream = null;

    if (ac) { try { ac.close(); } catch {} }
    ac = null;

    data = null;
    stopBtn.disabled = true;
    drawIdle();
    log('Stopped', 'warn');
  }

  async function startWithStreams(originalStream) {
    // Defensive: avoid blank page from unhandled exceptions
    try {
      stop(); // stop any previous run

      stream = originalStream;

      // Make an audio-only stream for WebAudio (reduces weirdness/crashes with video tracks)
      const audioTracks = stream.getAudioTracks();
      if (!audioTracks || audioTracks.length === 0) {
        log('No audio track received. When sharing a tab, ensure "Share tab audio" is enabled. YT Music sometimes shares video-only if audio isn’t allowed.', 'err');
        // Keep the original stream stopped so the capture UI doesn’t linger
        try { stream.getTracks().forEach(t => t.stop()); } catch {}
        stream = null;
        return;
      }
      audioStream = new MediaStream(audioTracks);

      attachStreamEndHandlers(stream, 'Capture');
      attachStreamEndHandlers(audioStream, 'Audio');

      ac = new (window.AudioContext || window.webkitAudioContext)();
      log(`AudioContext state=${ac.state}, sampleRate=${ac.sampleRate}`, 'ok');

      analyser = ac.createAnalyser();
      setupAnalyser();

      // Some browsers start suspended; resume explicitly (still requires user gesture, which we have via click)
      if (ac.state === 'suspended') {
        await ac.resume();
        log(`AudioContext resumed: state=${ac.state}`, 'ok');
      }

      src = ac.createMediaStreamSource(audioStream);
      src.connect(analyser);

      stopBtn.disabled = false;
      draw();
      log('Started', 'ok');
    } catch (e) {
      logErr('startWithStreams failed', e);
      stop();
    }
  }

  // ---------- Drawing ----------
  function drawIdle() {
    resize();
    const style = getStyleConfig();
    const bg = buildDirectionalGradient(
      style.backgroundGradientStart,
      style.backgroundGradientEnd,
      style.backgroundGradientDir,
      canvas.width,
      canvas.height,
      style.backgroundColor
    );
    ctx2d.fillStyle = bg;
    ctx2d.fillRect(0,0,canvas.width,canvas.height);
    ctx2d.fillStyle = '#666';
    ctx2d.textAlign = 'center';
    ctx2d.textBaseline = 'middle';
    ctx2d.font = `${Math.floor(canvas.height/18)}px system-ui`;
    ctx2d.fillText('RTA idle', canvas.width / 2, canvas.height / 2 - 12);
    ctx2d.font = '14px system-ui';
    ctx2d.fillText('Choose Mic or Screen/Tab audio', canvas.width / 2, canvas.height / 2 + 16);
  }

  function refreshStylePreview() {
    if (!raf) drawIdle();
  }

  function drawGrid(w, h, style) {
    if (gridShowChk && !gridShowChk.checked) return;
    const gridWidth = Math.max(0.5, style.gridLineWidth || 1);
    ctx2d.strokeStyle = style.gridColor;
    ctx2d.lineWidth = gridWidth;
    ctx2d.beginPath();

    const freqs = gridFrequencies(ac.sampleRate);
    for (const hz of freqs) {
      const x = hzToX(hz, ac.sampleRate, w);
      ctx2d.moveTo(x, 0);
      ctx2d.lineTo(x, h);
    }
    for (let y=0; y<=10; y++) {
      const yy = (y/10) * h;
      ctx2d.moveTo(0, yy);
      ctx2d.lineTo(w, yy);
    }
    ctx2d.stroke();

    if (labelsChk.checked) {
      ctx2d.fillStyle = '#6f6f6f';
      ctx2d.font = '12px system-ui';
      ctx2d.textAlign = 'center';
      ctx2d.textBaseline = 'top';
      for (const hz of freqs) {
        const x = hzToX(hz, ac.sampleRate, w);
        const xx = Math.max(16, Math.min(w - 16, x));
        ctx2d.fillText(fmtHz(hz), xx, 6);
      }
    }
  }

  function drawFftLine(w, h, style) {
    const lineWidth = Math.max(0.5, style.fftLineWidth || DEFAULT_SETTINGS.fftLineWidth);
    ctx2d.strokeStyle = style.fftLineColor;
    ctx2d.lineWidth = lineWidth;
    ctx2d.beginPath();

    const binCount = data.length;
    const { minHz, maxHz } = getHzLimits(ac.sampleRate);
    const isLogScale = scaleSel.value === 'log';
    const leftX = isLogScale ? hzToX(minHz, ac.sampleRate, w) : 0;
    if (peakHoldEnabled) ensureFftPeaks(binCount);
    else fftPeaks = null;

    let started = false;
    for (let i=0; i<binCount; i++) {
      const hz = binToHz(i, binCount, ac.sampleRate);
      if (hz < minHz || hz > maxHz) continue;

      const x = hzToX(hz, ac.sampleRate, w);
      const v = data[i] / 255;
      const y = (1 - v) * h;

      if (peakHoldEnabled && fftPeaks) {
        fftPeaks[i] = Math.max(fftPeaks[i], v);
      }

      if (!started) {
        if (isLogScale && x > leftX) {
          ctx2d.moveTo(leftX, y);
          ctx2d.lineTo(x, y);
        } else {
          ctx2d.moveTo(x, y);
        }
        started = true;
      } else {
        ctx2d.lineTo(x, y);
      }
    }
    ctx2d.stroke();

    if (peakHoldEnabled && fftPeaks) {
      ctx2d.strokeStyle = '#f7b';
      ctx2d.lineWidth = 1;
      ctx2d.beginPath();
      let startedPeak = false;
      for (let i=0; i<binCount; i++) {
        const hz = binToHz(i, binCount, ac.sampleRate);
        if (hz < minHz || hz > maxHz) continue;
        const peak = fftPeaks[i];
        if (!peak) continue;
        const x = hzToX(hz, ac.sampleRate, w);
        const y = (1 - peak) * h;
        if (!startedPeak) {
          ctx2d.moveTo(x, y);
          startedPeak = true;
        } else {
          ctx2d.lineTo(x, y);
        }
      }
      ctx2d.stroke();
    }
  }

  function drawOctaveBars(w, h, bandSet, labelStep = 3, style) {
    if (!bandSet.length) return;

    if (peakHoldEnabled) ensureBandPeaks(bandSet.length);
    else bandPeaks = null;

    const barFill = buildDirectionalGradient(
      style.barGradientStart,
      style.barGradientEnd,
      style.barGradientDir,
      w,
      h,
      style.barColor
    );
    ctx2d.fillStyle = barFill;
    const outlineWidth = Math.max(0, style.barLineWidth || 0);

    for (let i=0; i<bandSet.length; i++) {
      const band = bandSet[i];
      const x1 = hzToX(band.f1, ac.sampleRate, w);
      const x2 = hzToX(band.f2, ac.sampleRate, w);
      const bw = Math.max(1, x2 - x1);

      const v = bandLevel01(band, ac.sampleRate);
      const y = (1 - v) * h;

      if (peakHoldEnabled && bandPeaks) {
        bandPeaks[i] = Math.max(bandPeaks[i], v);
      }

      const pad = Math.min(2, bw * 0.15);
      const xx = x1 + pad;
      const ww = Math.max(1, bw - pad * 2);
      ctx2d.fillRect(xx, y, ww, h - y);

      if (outlineWidth > 0) {
        ctx2d.strokeStyle = style.barColor;
        ctx2d.lineWidth = outlineWidth;
        ctx2d.strokeRect(xx, y, ww, h - y);
      }

      if (peakHoldEnabled && bandPeaks) {
        const peak = bandPeaks[i];
        if (peak > 0) {
          const yPeak = Math.max(0, (1 - peak) * h - 2);
          ctx2d.fillStyle = '#f7b';
          ctx2d.fillRect(xx, yPeak, ww, 2);
          ctx2d.fillStyle = barFill;
        }
      }
    }

    if (!labelsChk.checked) return;
    ctx2d.fillStyle = '#6f6f6f';
    ctx2d.font = '11px system-ui';
    ctx2d.textAlign = 'center';
    ctx2d.textBaseline = 'bottom';

    const step = Math.max(1, labelStep);
    for (let i=0; i<bandSet.length; i += step) {
      const band = bandSet[i];
      const x = hzToX(band.fc, ac.sampleRate, w);
      const xx = Math.max(16, Math.min(w - 16, x));
      ctx2d.fillText(fmtHz(band.fc, { roundTo: 10 }), xx, h - 6);
    }
  }

  function drawThirdOctaveBars(w, h, style) {
    const b = buildThirdOctaveBands(ac.sampleRate);
    const step = (scaleSel.value === 'lin') ? 3 : 4;
    drawOctaveBars(w, h, b, step, style);
  }

  function drawAutoOctaveBars(w, h, style) {
    const { minHz, maxHz } = getHzLimits(ac.sampleRate);
    const divisor = resolveOctaveDivisor(minHz, maxHz);
    const b = buildOctaveBands(ac.sampleRate, divisor);
    const step = Math.max(1, Math.floor(divisor / 2));
    drawOctaveBars(w, h, b, step, style);
  }

  function draw() {
    try {
      raf = requestAnimationFrame(draw);

      // Guard against race conditions / capture ending
      if (!analyser || !ac || !data) return;
      if (!isFrozen) analyser.getByteFrequencyData(data);

      const w = canvas.width, h = canvas.height;
      const style = getStyleConfig();
      const bgFill = buildDirectionalGradient(
        style.backgroundGradientStart,
        style.backgroundGradientEnd,
        style.backgroundGradientDir,
        w,
        h,
        style.backgroundColor
      );
      ctx2d.fillStyle = bgFill;
      ctx2d.fillRect(0,0,w,h);

      drawGrid(w, h, style);

      if (viewSel.value === 'third') drawThirdOctaveBars(w, h, style);
      else if (viewSel.value === 'autoOctave') drawAutoOctaveBars(w, h, style);
      else drawFftLine(w, h, style);

      // footer
      ctx2d.fillStyle = '#777';
      ctx2d.font = '12px system-ui';
      ctx2d.textAlign = 'left';
      ctx2d.textBaseline = 'alphabetic';
      const { minHz, maxHz } = getHzLimits(ac.sampleRate);
      const viewLabel = viewSel.value === 'third' ? '1/3-oct' : viewSel.value === 'autoOctave' ? '1/x-oct' : 'FFT';
      ctx2d.fillText(
        `${ac.sampleRate} Hz | ${viewLabel} | ${scaleSel.value.toUpperCase()} | ${Math.round(minHz)}..${Math.round(maxHz)} Hz`,
        10, h - 10
      );
    } catch (e) {
      logErr('draw() failed', e);
      stop();
    }
  }

  // ---------- UI events ----------
  micBtn.addEventListener('click', async () => {
    try {
      log('Requesting mic...', 'ok');
      const s = await navigator.mediaDevices.getUserMedia({
        audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false },
        video: false
      });
      await startWithStreams(s);
    } catch (e) {
      logErr('Mic capture failed', e);
    }
  });

  screenBtn.addEventListener('click', async () => {
    try {
      log('Requesting screen/tab capture (pick a tab + enable "Share tab audio")...', 'ok');

      // Note: video:true is required by some browsers to allow audio capture from tab/screen
      const s = await navigator.mediaDevices.getDisplayMedia({
        video: true,
        audio: true
      });

      const aTracks = s.getAudioTracks().length;
      const vTracks = s.getVideoTracks().length;
      log(`Capture tracks: audio=${aTracks}, video=${vTracks}`, aTracks ? 'ok' : 'warn');

      await startWithStreams(s);
    } catch (e) {
      logErr('Screen/tab capture failed', e);
    }
  });

  stopBtn.addEventListener('click', stop);

  fftSel.addEventListener('change', () => { if (analyser) setupAnalyser(); });
  smooth.addEventListener('input', () => { if (analyser) analyser.smoothingTimeConstant = parseFloat(smooth.value); });
  dbSel.addEventListener('change', () => {
    if (!analyser) return;
    const [a,b] = dbSel.value.split(',').map(Number);
    analyser.minDecibels = a;
    analyser.maxDecibels = b;
  });
  if (bankSel) {
    bankSel.addEventListener('change', () => {
      const action = bankSel.value;
      if (!action) return;
      handleBankAction(action);
      bankSel.value = '';
    });
  }
  if (stylePresetSel) {
    stylePresetSel.addEventListener('change', () => {
      const action = stylePresetSel.value;
      if (!action) return;
      const label = stylePresetSel.options[stylePresetSel.selectedIndex]?.text;
      if (action === 'style-reset') {
        applyStyleValues(DEFAULT_SETTINGS);
        log('Style reset to defaults', 'ok');
      } else {
        const preset = STYLE_PRESETS[action];
        if (preset) {
          applyStyleValues(preset);
          if (label) log(`Style preset: ${label}`, 'ok');
        }
      }
      stylePresetSel.value = '';
    });
  }

  const styleReactiveElements = [
    barColorPicker,
    barGradientStartPicker,
    barGradientEndPicker,
    barGradientDirSel,
    barLineWidthInput,
    fftLineColorPicker,
    fftLineWidthInput,
    gridShowChk,
    gridColorPicker,
    gridLineWidthInput,
    bgColorPicker,
    bgGradientStartPicker,
    bgGradientEndPicker,
    bgGradientDirSel
  ].filter(Boolean);
  styleReactiveElements.forEach(el => {
    el.addEventListener('input', refreshStylePreview);
    if (el instanceof HTMLSelectElement) {
      el.addEventListener('change', refreshStylePreview);
    }
  });

  function dynamicMinHzStep(value) {
    const v = Number(value);
    if (!Number.isFinite(v)) return 0.1;
    if (v < 10) return 0.1;
    if (v < 100) return 1;
    return 10;
  }

  function updateMinHzStep() {
    if (!minHzEl) return;
    const step = dynamicMinHzStep(minHzEl.value);
    minHzEl.step = String(step);
  }

  function invalidateBands() { bandsCacheKey = ''; }
  minHzEl.addEventListener('input', invalidateBands);
  minHzEl.addEventListener('input', updateMinHzStep);
  maxHzEl.addEventListener('input', invalidateBands);
  viewSel.addEventListener('change', () => {
    invalidateBands();
    updateAutoOctControlsVisibility();
    if (peakHoldEnabled) resetPeakHoldData();
    hideTooltip();
  });
  if (octaveDivisorEl) octaveDivisorEl.addEventListener('input', invalidateBands);
  if (octaveAutoChk) octaveAutoChk.addEventListener('change', invalidateBands);

  updateAutoOctControlsVisibility();
  ensureDefaultBanks();
  updateMinHzStep();
  updateLogVisibility();
  toggleMenuPanel(true);
  setRowVisible('source', true);
  setMenuCollapsedState(false);
  drawIdle();
  log('Ready', 'ok');
    setFreezeState(false);

  document.addEventListener('keydown', (ev) => {
    const target = ev.target;
    if (target instanceof HTMLInputElement || target instanceof HTMLSelectElement || target instanceof HTMLTextAreaElement || target?.isContentEditable) {
      return;
    }
    const key = ev.key;
    if (ev.code === 'Space' || key === ' ') {
      ev.preventDefault();
      setFreezeState(!isFrozen);
      return;
    }
    if (key === '1' || key === '2' || key === '3') {
      ev.preventDefault();
      handleBankAction(`bank-${key}-load`);
      return;
    }
    if (key === 'ArrowLeft' || key === 'ArrowRight') {
      ev.preventDefault();
      const step = parseFloat(maxHzEl.step) || 100;
      const decimals = Math.max(0, (step.toString().split('.')[1] || '').length);
      const current = parseFloat(maxHzEl.value) || 0;
      const dir = key === 'ArrowRight' ? 1 : -1;
      maxHzEl.value = String(Number((current + dir * step).toFixed(decimals)));
      maxHzEl.dispatchEvent(new Event('input', { bubbles: true }));
      return;
    }
    if (key === 'ArrowUp' || key === 'ArrowDown') {
      ev.preventDefault();
      const step = dynamicMinHzStep(minHzEl.value);
      const decimals = Math.max(0, (step.toString().split('.')[1] || '').length);
      const current = parseFloat(minHzEl.value) || 0;
      const dir = key === 'ArrowUp' ? 1 : -1;
      minHzEl.value = String(Number((current + dir * step).toFixed(decimals)));
      minHzEl.dispatchEvent(new Event('input', { bubbles: true }));
      return;
    }
    if (key.toLowerCase() === 'l') {
      ev.preventDefault();
      const nextIndex = (viewSel.selectedIndex + 1) % viewSel.options.length;
      viewSel.selectedIndex = nextIndex;
      viewSel.dispatchEvent(new Event('change', { bubbles: true }));
      return;
    }
    if (key.toLowerCase() === 'f') {
      ev.preventDefault();
      setFreezeState(!isFrozen);
      return;
    }
    if (key.toLowerCase() === 'r') {
      ev.preventDefault();
      resetPeakHoldData();
      return;
    }
    if (key.toLowerCase() === 'p' && peakHoldChk) {
      ev.preventDefault();
      peakHoldChk.checked = !peakHoldChk.checked;
      setPeakHold(peakHoldChk.checked);
      return;
    }
    if (key.toLowerCase() === 'g' && gridShowChk) {
      ev.preventDefault();
      gridShowChk.checked = !gridShowChk.checked;
      refreshStylePreview();
      return;
    }
    if (key.toLowerCase() === 'h' && labelsChk) {
      ev.preventDefault();
      labelsChk.checked = !labelsChk.checked;
      refreshStylePreview();
      return;
    }
    if (key.toLowerCase() === 'm') {
      ev.preventDefault();
      micBtn.click();
      return;
    }
    if (key.toLowerCase() === 't') {
      ev.preventDefault();
      screenBtn.click();
      return;
    }
    if (key.toLowerCase() === 's') {
      ev.preventDefault();
      stopBtn.click();
    }
  });

  document.addEventListener('wheel', (ev) => {
    const target = ev.target;
    if (!(target instanceof HTMLInputElement)) return;
    if (target.type !== 'number') return;
    const step = target.id === 'minHz'
      ? dynamicMinHzStep(target.value)
      : (parseFloat(target.step) || 1);
    const decimals = Math.max(0, (step.toString().split('.')[1] || '').length);
    ev.preventDefault();
    const direction = ev.deltaY > 0 ? -1 : 1;
    const current = parseFloat(target.value) || 0;
    const nextValue = Number((current + direction * step).toFixed(decimals));
    target.value = String(nextValue);
    target.dispatchEvent(new Event('input', { bubbles: true }));
  }, { passive: false });
})();
</script>
</body>
</html>
